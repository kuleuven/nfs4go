package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"
)

func main() {
	for _, arg := range os.Args[1:] {
		if arg == "--" {
			continue
		}

		if err := parse(arg); err != nil {
			panic(err)
		}
	}
}

const header = `// This file was automatically generated by go generate; DO NOT EDIT
package %s

// This file contains specialed Decode and Encode functions
// to avoid the use of the reflect package while encoding.
// In principal, everything should work when commenting out
// this file.

import "github.com/kuleuven/nfs4go/xdr"`

const empty = `func (x *%s) Decode(decoder *xdr.Decoder) error {
	return nil // Empty struct
}
	
func (x %s) Encode(encoder *xdr.Encoder) error {
	return nil // Empty struct
}`

const definition = `func (x *%s) Decode(decoder *xdr.Decoder) error {
	return decoder.DecodeAll(%s)
}
	
func (x %s) Encode(encoder *xdr.Encoder) error {
	return encoder.EncodeAll(%s)
}`

const definitionStar = `func (x *%s) Decode(decoder *xdr.Decoder) error {
	if err := decoder.DecodeAll(%s); err != nil {
		return err
	}

	if ok, err := decoder.Bool(); err != nil || !ok {
		return err
	}

	%s = new(%s)

	return decoder.Decode(%s)
}
	
func (x %s) Encode(encoder *xdr.Encoder) error {
	if err := encoder.EncodeAll(%s); err != nil {
		return err
	}

	if %s == nil {
		return encoder.Bool(false)
	}

	if err := encoder.Bool(true); err != nil {
		return err
	}

	return encoder.Encode(*%s)
}`

const starDefinition = `func (x *%s) Decode(decoder *xdr.Decoder) error {
	if ok, err := decoder.Bool(); err != nil {
		return err
	} else if ok {
	 	%s = new(%s)

		if err := decoder.Decode(%s); err != nil {
			return err
		}
	}

	return decoder.DecodeAll(%s)
}
	
func (x %s) Encode(encoder *xdr.Encoder) error {
	ok := %s != nil

	if err := encoder.Bool(ok); err != nil {
		return err
	}

	if ok {
		if err := encoder.Encode(*%s); err != nil {
			return err
		}
	}

	return encoder.EncodeAll(%s)
}`

const union = `func (x *%s) Decode(decoder *xdr.Decoder) error {
	return decoder.Union(%s)
}
	
func (x %s) Encode(encoder *xdr.Encoder) error {
	return encoder.Union(%s)
}`

func parse(filename string) error {
	src, err := os.ReadFile(filename)
	if err != nil {
		return err
	}

	fset := token.NewFileSet() // positions are relative to fset

	node, err := parser.ParseFile(fset, "src.go", src, parser.AllErrors)
	if err != nil {
		return err
	}

	var out bytes.Buffer

	out.WriteString(fmt.Sprintf(header, node.Name.Name))

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			if typeSpec, ok := spec.(*ast.TypeSpec); ok {
				if def, ok := typeSpec.Type.(*ast.StructType); ok {
					out.WriteString("\n\n")

					addDefinition(&out, typeSpec.Name.Name, def)
				}
			}
		}
	}

	target := filename[:len(filename)-3] + "_xdr.go"

	return os.WriteFile(target, out.Bytes(), 0o600)
}

func addDefinition(w io.Writer, name string, def *ast.StructType) {
	if len(def.Fields.List) == 0 {
		fmt.Fprintf(w, empty, name, name)

		return
	}

	if tag := def.Fields.List[0].Tag; tag != nil && strings.Contains(tag.Value, `xdr:"union"`) {
		addUnion(w, name, def)

		return
	}

	if x, ok := def.Fields.List[0].Type.(*ast.StarExpr); ok {
		addStarStruct(w, name, def, x)
	}

	if x, ok := def.Fields.List[len(def.Fields.List)-1].Type.(*ast.StarExpr); ok {
		addStructStar(w, name, def, x)
	}

	addStruct(w, name, def)
}

func collectFields(fields []*ast.Field) ([]string, []string, bool) {
	decodeList := make([]string, 0, len(fields))
	encodeList := make([]string, 0, len(fields))

	for _, field := range fields {
		fieldName := field.Names[0].Name

		if _, ok := field.Type.(*ast.StarExpr); ok {
			return nil, nil, false
		}

		decodeList = append(decodeList, "&x."+fieldName)
		encodeList = append(encodeList, "x."+fieldName)
	}

	return decodeList, encodeList, len(fields) > 0
}

func addStruct(w io.Writer, name string, def *ast.StructType) {
	decodeList, encodeList, ok := collectFields(def.Fields.List)
	if ok {
		fmt.Fprintf(w, definition, name, strings.Join(decodeList, ", "), name, strings.Join(encodeList, ", "))
	}
}

func addUnion(w io.Writer, name string, def *ast.StructType) {
	decodeList, encodeList, ok := collectFields(def.Fields.List)
	if ok {
		fmt.Fprintf(w, union, name, strings.Join(decodeList, ", "), name, strings.Join(encodeList, ", "))
	}
}

func addStructStar(w io.Writer, name string, def *ast.StructType, x *ast.StarExpr) {
	fieldName := def.Fields.List[len(def.Fields.List)-1].Names[0].Name

	decodeList, encodeList, ok := collectFields(def.Fields.List[:len(def.Fields.List)-1])
	if ok {
		fmt.Fprintf(w,
			definitionStar,
			name, strings.Join(decodeList, ", "), "x."+fieldName, x.X, "x."+fieldName,
			name, strings.Join(encodeList, ", "), "x."+fieldName, "x."+fieldName,
		)
	}
}

func addStarStruct(w io.Writer, name string, def *ast.StructType, x *ast.StarExpr) {
	fieldName := def.Fields.List[0].Names[0].Name

	decodeList, encodeList, ok := collectFields(def.Fields.List[1:])
	if ok {
		fmt.Fprintf(w,
			starDefinition,
			name, "x."+fieldName, x.X, "x."+fieldName, strings.Join(decodeList, ", "),
			name, "x."+fieldName, "x."+fieldName, strings.Join(encodeList, ", "),
		)
	}
}
